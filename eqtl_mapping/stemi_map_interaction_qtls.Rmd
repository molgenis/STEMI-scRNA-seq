---
title: "stemi_map_interaction_qtls"
output: html_document
date: "2023-01-19"
---

```{r header, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)
#!/usr/bin/env Rscript
############################################################################################################################
# Authors: Roy Oelen
# Name: stemi_map_interaction_qtls.Rmd
# Function:
############################################################################################################################
```

```{r libraries, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)
####################
# libraries        #
####################
# load genotype data
library(vcfR)
# to work in parallel
library(foreach)
library(doParallel)
# faster than dataframes
library(data.table)
# for the single cell data
library(Seurat)
# for the regression
library(lme4)
library(lmerTest)
library(nlme)
# for plotting
library(ggplot2)
library(cowplot)
```

```{r objects, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, warning = FALSE, message = FALSE)
####################
# objects.         #
####################
# object to hold the genotype information
Genotypes <- setRefClass('Genotypes',
  fields = list(
    # the snps
    calls = 'data.table',
    # the metadata
    meta = 'data.table'
  ),
  methods = list(
    get_genotypes = function(.self, snp_id=NULL, chrom_pos=NULL, snp_pos=NULL, convert_alleles=F) {
      # we need the index of the SNP
      snp_index <- NULL
      if (!is.null(snp_id)) {
        # extract snp index
        snp_index <- grep(snp_id, .self$meta[['ID']])

      } else if (!is.null(chrom_pos) & !is.null(snp_pos)) {
        # extract snp index
        snp_index <- which(.self$meta[['CHROM']] == chrom_pos & .self$meta[['POS']] == snp_pos)

      } else {
        stop("Need to supply the variant ID, or both the CHROM and SNP positions")
      }
      # grab the genotypes
      genotypes_raw <- as.vector(unlist(.self$calls[snp_index, ]))
      # convert to alleles if requested
      if (convert_alleles) {
        # get the ref
        ref <- .self$meta[snp_index, 'REF'][['REF']][1]
        # and alt
        alt <- .self$meta[snp_index, 'ALT'][['ALT']][1]
        # harmonize placement of slash
        genotypes_raw <- gsub('1\\|0', '0\\|1', genotypes_raw)
        genotypes_raw <- gsub('1/0', '0/1', genotypes_raw)
        # replace letters
        genotypes_raw <- gsub('0', ref, genotypes_raw)
        genotypes_raw <- gsub('1', alt, genotypes_raw)
      }
      # turn into list
      genotypes_raw <- as.list(genotypes_raw)
      # add the participants as the keys
      names(genotypes_raw) <- colnames(.self$calls)
      return(genotypes_raw)
    },
    get_available_variants = function(.self){
      return(.self$meta[['ID']])
    }
  )
)

```

```{r functions, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, warning = FALSE, message = FALSE)
####################
# Functions        #
####################

create_genotypes_object <- function(genotypes_vcf){
  # get the donors in the genotype data
  donors_vcf <- colnames(genotypes_vcf@gt)
  # get the intersection
  donors <- setdiff(donors_vcf, c('FORMAT'))
  # and the genotype data itself
  gt_calls <- data.table(extract.gt(genotypes_vcf)[, donors])
  # grab the genotypes
  gt_metadata <- data.table(genotypes_vcf@fix[, c('CHROM', 'POS', 'ID', 'REF', 'ALT')])
  # create object
  genos <- Genotypes$new(calls = gt_calls, meta = gt_metadata)
  return(genos)
}

olink_to_plottable_table <- function(olink, split_char='\\.'){
  id_and_timepoint_df <- NULL
  # check the rownames
  for(id_and_timepoint in rownames(olink)){
    # split into id and timepoint
    id_and_timepoint_split <- strsplit(id_and_timepoint, split_char)
    id <- id_and_timepoint_split[[1]][[1]]
    timepoint <- id_and_timepoint_split[[1]][[2]]
    # turn into row
    id_and_timepoint_row <- data.frame(id=c(id), timepoint=c(timepoint))
    # add to dataframe
    if(is.null(id_and_timepoint_df)){
      id_and_timepoint_df <- id_and_timepoint_row
    }
    else{
      id_and_timepoint_df <- rbind(id_and_timepoint_df, id_and_timepoint_row)
    }
  }
  # add new columns to original data
  olink <- cbind(id_and_timepoint_df, olink)
  return(olink)
}

olink_to_vertical <- function(olink, metadata_tables=c('id', 'timepoint')) {
  # put each olink in a list
  data_per_protein <- list()
  # get the columns that would be proteins
  proteins <- setdiff(colnames(olink), metadata_tables)
  # check each protein
  for (protein in proteins) {
    # get the metadata
    data_protein <- olink[, c(metadata_tables)]
    # add the protein as a column
    data_protein[['protein']] <- protein
    # add the actual values
    data_protein[['expression']] <- olink[[protein]]
    # add to the list
    data_per_protein[[protein]] <- data_protein
  }
  data_proteins <- do.call("rbind", data_per_protein)
  return(data_proteins)
}


# get the gene expression from from the assay and slot
get_gene_expression = function(seurat_object, genes, assay='SCT', slot='data', metadata_columns=c('assignment.final', 'timepoint.final', 'cell_type')){
  # init the expression matrix
  expression_matrix <- NULL
  if (assay == 'SCT' & slot == 'counts'){
    expression_matrix <- as.data.frame(t(as.matrix(seurat_object@assays$SCT@counts[intersect(genes, rownames(seurat_object@assays$SCT@counts)), ])))
  }
  else if (assay == 'SCT' & slot == 'data'){
    expression_matrix <- as.data.frame(t(as.matrix(seurat_object@assays$SCT@data[intersect(genes, rownames(seurat_object@assays$SCT@data)), ])))
  }
  else if (assay == 'SCT' & slot == 'scale.data'){
    expression_matrix <- as.data.frame(t(as.matrix(seurat_object@assays$SCT@scale.data[intersect(genes, rownames(seurat_object@assays$SCT@scale.data)), ])))
  }
  else if (assay == 'RNA' & slot == 'counts'){
    expression_matrix <- as.data.frame(t(as.matrix(seurat_object@assays$RNA@counts[intersect(genes, rownames(seurat_object@assays$RNA@counts)), ])))
  }
  else if (assay == 'RNA' & slot == 'data'){
    expression_matrix <- as.data.frame(t(as.matrix(seurat_object@assays$RNA@data[intersect(genes, rownames(seurat_object@assays$RNA@data)), ])))
  }
  else if (assay == 'RNA' & slot == 'scale.data'){
    expression_matrix <- as.data.frame(t(as.matrix(seurat_object@assays$RNA@scale.data[intersect(genes, rownames(seurat_object@assays$RNA@scale.data)), ])))
  }
  # add the metadata, should be in the same order as the expression data
  expression_matrix <- cbind(seurat_object@meta.data[, metadata_columns], expression_matrix)
  return(expression_matrix)
}


wide_to_long_table <- function(wide_table, metadata_columns=c('assignment.final', 'timepoint.final')) {
  # we will create the table per gene
  table_per_gene <- list()
  # get the genes
  genes <- setdiff(colnames(wide_table), metadata_columns)
  # check each gene
  for (gene in genes) {
    # extract metadata
    table_gene <- wide_table[, metadata_columns]
    # set the gene
    table_gene[['gene']] <- gene
    # set the expression
    table_gene[['expression']] <- wide_table[[gene]]
    # add to list
    table_per_gene[[gene]] <- table_gene
  }
  # merge all the table
  table_all_genes <- do.call("rbind", table_per_gene)
  return(table_all_genes)
}

get_mean_expression_matrices <- function(seurat_object, metadata_columns=c('cell_type', 'assignment.final', 'timepoint.final'), assay='SCT', slot='data') {
  # check at the last metadata column
  categories_to_check <- metadata_columns[length(metadata_columns)]
  # set as the ident
  Idents(seurat_object) <- categories_to_check

  # # SINGLETHREADED
  #
  # # we will save for each category
  # expression_per_category <- list()
  # # and we will calculate per category
  # for (category in unique(seurat_object@meta.data[[categories_to_check]])) {
  #   # subset to that category
  #   seurat_object_category <- seurat_object[, seurat_object@meta.data[[categories_to_check]] == category]
  #   # we will get average expression for this category
  #   expression_matrix_category <- NULL
  #   # if this is the last category, we can just extract the average expression
  #   if (length(metadata_columns) == 1) {
  #     expression_matrix_category <- AverageExpression(seurat_object_category, assays = c(assay), slot = slot)[[assay]]
  #     # turn into dataframe
  #     expression_matrix_category <- data.frame(expression_matrix_category)
  #     # set the genes
  #     expression_matrix_category[['gene']] <- rownames(expression_matrix_category)
  #   }
  #   # if we still have more categories, we have to recursively call this function again, excluding this category
  #   else {
  #     expression_matrix_category <- get_mean_expression_matrices(seurat_object = seurat_object_category, metadata_columns = metadata_columns[1 : (length(metadata_columns) - 1)], assay = assay, slot = slot)
  #   }
  #
  #   # add the category to the expression matrix
  #   expression_matrix_category[[categories_to_check]] <- category
  #   # add to the list
  #   expression_per_category[[category]] <- expression_matrix_category
  # }

  # MULTITHREADED

  expression_per_category <- foreach(category = unique(seurat_object@meta.data[[categories_to_check]])) %dopar% {
    expression_matrix_category <- NULL
  #   # if this is the last category, we can just extract the average expression
    if (length(metadata_columns) == 1) {
      # we do the subset in a separate function, Seurat sometimes has unpredictable behavior otherwise
      expression_matrix_category <- subset_and_get_get_mean_expression(seurat_object, categories_to_check, category, assay, slot)
    }
    # if we still have more categories, we have to recursively call this function again, excluding this category
    else {
      expression_matrix_category <- subset_and_get_mean_expression_matrices(seurat_object, categories_to_check, category, metadata_columns[1 : (length(metadata_columns) - 1)], assay, slot)
    }
    # add the category to the expression matrix
    expression_matrix_category[[categories_to_check]] <- category
    return(expression_matrix_category)
  }

  # now add the tables of these categories together
  expression_all_categories <- do.call("rbind", expression_per_category)
  # make the expression have a better column name
  #expression_all_categories[['expression']] <- expression_all_categories[['all']]
  # and remove the original
  #expression_all_categories[['all']] <- NULL
  return(expression_all_categories)
}

subset_and_get_mean_expression_matrices <- function(seurat_object, metadata_column_to_subset_by, metadata_column_value_to_subset_by, metadata_columns=c('cell_type', 'assignment.final', 'timepoint.final'), assay='SCT', slot='data'){
  seurat_object_category <- seurat_object[, seurat_object@meta.data[[metadata_column_to_subset_by]] == metadata_column_value_to_subset_by]
  expression_matrix_category <- get_mean_expression_matrices(seurat_object = seurat_object_category, metadata_columns = metadata_columns, assay = assay, slot = slot)
  return(expression_matrix_category)
}

subset_and_get_get_mean_expression <- function(seurat_object, metadata_column_to_subset_by, metadata_column_value_to_subset_by, assay, slot) {
  # subset
  seurat_object_subset <- seurat_object[, seurat_object@meta.data[[metadata_column_to_subset_by]] == metadata_column_value_to_subset_by]
  # calculate averaage expression
  expression_matrix <- AverageExpression(seurat_object_subset, assays = c(assay), slot = slot)[[assay]]
  # turn into dataframe
  expression_matrix <- data.frame(expression_matrix)
  # set gene names
  expression_matrix[['gene']] <- rownames(expression_matrix)
  return(expression_matrix)
}

add_genotypes <- function(expression_data, genotype_object, variant, participant_column='assignment.final', genotype_column=NULL) {
  # extract the genotypes
  genotypes_dict <- genotype_object$get_genotypes(variant, convert_alleles = T)
  # turn into dataframe, that way it is easier to handle missing data
  genotypes_table <- data.frame(participant = names(genotypes_dict), genotype = as.vector(unlist(genotypes_dict)))
  # add to the table by matching the IDs
  expression_data[[variant]] <- genotypes_table[match(expression_data[[participant_column]], genotypes_table[['participant']]), 'genotype']
  # if we wanted a different name, we will do so
  if (!is.null(genotype_column)) {
    expression_data[[genotype_column]] <- expression_data[[variant]]
    # remove the original name
    #expression_data[[variant]] <- NULL
  }
  return(expression_data)
}

perform_regression <- function(data, string_formula, use_lme4=F) {
  # perform the regression
  regression_result <- NULL
  # lme4 is faster, but does not compute P values
  if (use_lme4) {
    regression_result <- lmer(formula = as.formula(string_formula), data = data)
  }
  else{
    regression_result <- lme(fixed = string_formula[['fixed']], random=string_formula[['random']], data = data)
  }
  return(regression_result)
}

do_regression_of_variant_probe <- function(probe_and_metadata, genotype_data, variant, probe, string_formula, probe_column='protein', id_column='id', use_lme4=F, na_omit=T){
   # subset the probe and metadata to that probe
    probe_metadata_probe <- probe_and_metadata[as.character(probe_and_metadata[[probe_column]]) == probe, ]
    # add the genotype
    probe_metadata_probe <- add_genotypes(probe_metadata_probe, genotype_data, variant, id_column, 'variant')
    # remove the '|' from the genotypes to avoid confusion
    probe_metadata_probe[['variant']] <- gsub('\\|', '', probe_metadata_probe[['variant']])
    # put result in the list
    result_list <- list('variant' = variant, 'probe' = probe)
    # we might have issues in cases where the genotypes are the same, missing
    tryCatch(
        {
          if (na_omit) {
            probe_metadata_probe <- na.omit(probe_metadata_probe)
          }
          # we can only progress if there is variance in the genotypes
          if (length(unique(probe_metadata_probe[[variant]])) > 1) {
            # perform the regression
            regression_result <- perform_regression(probe_metadata_probe, string_formula, use_lme4 = use_lme4)
            result_list[['result']] <- regression_result
          }
        },
        error=function(e) NULL
        # error=function(cond) {
        #   message(paste('error in variant-probe:', variant, '-', probe, '\n', sep = ''))
        #   message(cond)
        # }
    )
    return(result_list)
}


do_regression_per_variant_probe <- function(probe_and_metadata, genotype_data, confinement_table, string_formula, probe_column='protein', id_column='id', confinement_variant_column='variant', confinement_probe_column='probe', genotype_column='genotype', use_lme4=F, force_single_thread=F) {
  result_per_variant_probe <- NULL
  # single thread approach
  if (force_single_thread) {
    result_per_variant_probe <- list()
    # check each combination
    for(row_i in 1:nrow(confinement_table)){
      # extract the variant
      variant <- as.character(confinement_table[row_i, confinement_variant_column])
      # and the probe
      probe <-  as.character(confinement_table[row_i, confinement_probe_column])
      # get the result
      regression_result <- do_regression_of_variant_probe(probe_and_metadata, genotype_data, variant, probe, string_formula, probe_column, id_column, use_lme4)
      result_per_variant_probe[[paste(variant, probe, sep = '_')]] <- regression_result
    }
  }
  # multi-thread approach
  else{
    # check each combination
    result_per_variant_probe <- foreach(row_i = 1:nrow(confinement_table)) %dopar% {
      # extract the variant
      variant <- as.character(confinement_table[row_i, confinement_variant_column])
      # and the probe
      probe <-  as.character(confinement_table[row_i, confinement_probe_column])
      # get the result
      regression_result <- do_regression_of_variant_probe(probe_and_metadata, genotype_data, variant, probe, string_formula, probe_column, id_column, use_lme4)
      return(regression_result)
    }
    # add keys as variant-probe combinations
    variant_probe_keys <- paste(confinement_table[['variant']], confinement_table[['probe']], sep = '_')
    names(result_per_variant_probe) <- variant_probe_keys
  }
  return(result_per_variant_probe)
}


do_regression_per_celltype <- function(probe_and_metadata, genotype_data, confinement_table, string_formula, celltype_column='cell_type', probe_column='protein', id_column='id', confinement_variant_column='variant', confinement_probe_column='probe', genotype_column='genotype', use_lme4=F){
  # get the celltypes
  celltypes <- unique(as.character(probe_and_metadata[[celltype_column]]))
  # do per celltype
  regression_per_celltype <- foreach(celltype = celltypes) %dopar% {
    # subset to that celltype
    data_celltype <- probe_and_metadata[probe_and_metadata[[celltype_column]] == celltype, ]
    # we can only regress if there is data
    if (nrow(data_celltype) > 0) {
      # perform regression
      regression_celltype <- do_regression_per_variant_probe(probe_and_metadata = data_celltype, genotype_data = genotype_data, confinement_table = confinement_table, string_formula = string_formula, probe_column = probe_column, id_column = id_column, confinement_variant_column = confinement_variant_column, confinement_probe_column = confinement_probe_column, genotype_column = genotype_column, use_lme4 = use_lme4, force_single_thread=T)
      # add the celltype
      regression_celltype[['celltype']] <- celltype
      # return the result
      return(regression_celltype)
    }
    else {
      return(list('celltype' = celltype))
    }
  }
  # set the celltypes as keys
  names(regression_per_celltype) <- celltypes
  return(regression_per_celltype)
}

```

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)
####################
# Main Code        #
####################
# location of various files
olinkid_to_uid_loc <- '/groups/umcg-franke-scrna/tmp01/releases/blokland-2020/v1/protein_data/olink/olinkid_to_uniprotid.tsv'
uniprotid_to_gs_loc <- '/groups/umcg-franke-scrna/tmp01/releases/blokland-2020/v1/protein_data/olink/uniprot_to_genesymbol.tsv'
gs_to_ens_loc <- '/groups/umcg-franke-scrna/tmp01/releases/blokland-2020/v1/protein_data/features_v3.tsv'
olink_loc <- '/groups/umcg-franke-scrna/tmp01/releases/blokland-2020/v1/protein_data/olink/20200442_Groot_NPX-QC_format_fixed.tsv'
inclusion_list_loc <- '/groups/umcg-franke-scrna/tmp01/releases/blokland-2020/v1/metadata/included_participants.txt'
metadata_loc <- '/groups/umcg-franke-scrna/tmp01/releases/blokland-2020/v1/metadata//cardio.integrated.20210301.metadata.tsv'
age_sex_loc <- '/groups/umcg-franke-scrna/tmp01/releases/blokland-2020/v1/metadata/stemi_age_gender_match_wtestid.tsv'
# load mapping files
gs_to_ens <- read.table(gs_to_ens_loc, sep = '\t', header = F)
uniprotid_to_gs <- read.table(uniprotid_to_gs_loc, sep = '\t', header = T)
olinkid_to_uid <- read.table(olinkid_to_uid_loc, sep = '\t', header = T)

# location of the Seurat object
cardio_integrated_loc <- '/groups/umcg-franke-scrna/tmp01/releases/blokland-2020/v1/seurat/cardio.integrated.20210301.rds'

# location of the genotype data
genotypes_loc <- '/groups/umcg-franke-scrna/tmp01/releases/blokland-2020/v1/genotype/stemi_all_merged_aragam2022.vcf.gz'

```

```{r read_protein_data, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)

# read protein data
olink <- read.table(olink_loc, sep = '\t', header = T, row.names = 1)
# covert so that the timepoint is split as a separate column
olink_plottable <- olink_to_plottable_table(olink)
# get the participants to include
inclusion_list <- read.table(inclusion_list_loc, header = F)$V1
# subset to the ones we want to include
olink_plottable <- olink_plottable[!is.na(olink_plottable[['id']]) & olink_plottable[['id']] %in% inclusion_list, ]
# and make vertical
olink_vertical <- olink_to_vertical(olink_plottable)
```

```{r read_seurat, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)

# read seurat object
cardio_integrated <- readRDS(cardio_integrated_loc)

```

```{r mean_expression_chems, include=FALSE, fig.width=20, fig.height=20}
knitr::opts_chunk$set(echo = FALSE, warning = FALSE, message = FALSE)

# get mean expression of all V2
mean_expression_v2 <- get_mean_expression_matrices(cardio_integrated[, cardio_integrated@meta.data$orig.ident == 'stemi_v2'], metadata_columns=c('cell_type_lowerres', 'timepoint.final', 'assignment.final'))
mean_expression_v3 <- get_mean_expression_matrices(cardio_integrated[, cardio_integrated@meta.data$orig.ident == 'stemi_v3'], metadata_columns=c('cell_type_lowerres', 'timepoint.final', 'assignment.final'))
# add the chemistry as a variable
mean_expression_v2[['chem']] <- 'V2'
mean_expression_v3[['chem']] <- 'V3'
# combine them
mean_expression <- rbind(mean_expression_v2, mean_expression_v3)
# make the column names nicer
colnames(mean_expression) <- c('expression', 'gene', 'celltype', 'timepoint', 'assignment', 'chem')
```

```{r read_genotypes, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, warning = FALSE, message = FALSE)

# get genotype data
genotypes <- read.vcfR(genotypes_loc)
# turn into object
genotype_object <- create_genotypes_object(genotypes)

```

```{r add_sex_age, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, warning = FALSE, message = FALSE)

# read the age/sex file
age_sex <- read.table(age_sex_loc, header = T, sep = '\t')
# add to the mean expression
mean_expression[, c('age', 'sex')] <- age_sex[match(mean_expression[['assignment.final']], age_sex[['ID']]), c('age', 'gender')]
# and to the proteins
olink_vertical[, c('age', 'sex')] <- age_sex[match(olink_vertical[['id']], age_sex[['ID']]), c('age', 'gender')]
```

```{r pqtl_mapping, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, warning = FALSE, message = FALSE)

# combine all the SNPs with the proteins
pqtl_confinement <- expand.grid(genotype_object$get_available_variants(), unique(olink_vertical[['protein']]))
# set correct column names
colnames(pqtl_confinement) <- c('variant', 'probe')
# create the formula
formula_protein <- 'expression ~ age + sex + timepoint + variant + variant*timepoint + (1|id)'
# perform the regression
pqtl_output <- do_regression_per_variant_probe(olink_vertical, genotype_object, confinement_table = pqtl_confinement, string_formula = formula_protein, use_lme4 = T, force_single_thread = T)
```

```{r eqtl_mapping, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, warning = FALSE, message = FALSE)
# make a mapping
uniprot_proteins <- olinkid_to_uid[match(unique(unique(olink_vertical[['protein']])), olinkid_to_uid[['OlinkID']]), 'Uniprot.ID']
# remove NA
uniprot_proteins <- uniprot_proteins[!is.na(uniprot_proteins)]
# to gene symbol
gs_proteins <- uniprotid_to_gs[match(uniprot_proteins, uniprotid_to_gs[['From']]), 'To']
# create confinement
eqtl_confinement <- expand.grid(genotype_object$get_available_variants(), gs_proteins)
colnames(eqtl_confinement) <- c('variant', 'probe')
# make a formula
formula_rna <- 'expression ~ chem + age + sex + timepoint + variant + variant*timepoint + (1|assignment)'
# do regression per celltype
eqtl_output_per_celltype <- do_regression_per_celltype(mean_expression[mean_expression[['celltype']] %in% c('B', 'CD4T', 'CD8T', 'DC', 'monocyte', 'NK'), ], genotype_object, celltype_column = 'celltype', confinement_table = eqtl_confinement, string_formula = formula_rna, use_lme4 = T, id_column = 'assignment', probe_column = 'gene')
```
